/*
 * Библиотека функций линейной алгебры (кинематические фильтры)
 * Version: 0.7a
 * File: "la_cine.h"
 * Coding: UTF8
 * (C) 2007 Alex Zorg <azorg@mail.ru>
 * Licensed by GNU General Public License version 2
 * Last update: 2008.02.02
 */

#ifndef LA_CINE_H
#define LA_CINE_H

#include "la_filt.h" // линейные фильтры

// использовать КИХ фильтры, а не простые ФНЧ в
// классах кинематических фильтров
//#define LA_CINE_FIR

// использовать "быструю" реализацию кинематического фильтра
// (особенно буструю если неопределено LA_CINE_FIR)
#define LA_CINE_FAST

// постоянная времени (в числе тактов) используемая при коррекции
#define LA_CINE_FAST_CORR 1e9

// класс кинематического фильтра
// Идея фильтра:
//   На вход фильтра поступают сильно зашумленные выборки вектора
//   и его производная (например координата и скорость). Интегрирование
//   скорости позволяет получение хорошей оценки вектора, но на больших
//   временных интервалах происходит "накопление" ошибки. Накопление ошибки
//   можно присеч производя комплексную обработку и самого зашумленного
//   вектора и его производной.
//   Для интегрирования используется метод трапеций.
//   На коротких интервалах фильтр "доверяет" скорости, на больших учитывает
//   входное значение вектора.
//   С целью выделения корректного среднего значения вектора используется
//   фильтр (обычно ФНЧ).
typedef struct {
  la_integ_t integ; // интегратор для производной
#ifdef LA_CINE_FIR
  la_fir_t f1, f2; // фильтра ФНЧ
#else
  la_filt_t f1, f2; // фильтры ФНЧ
#endif
  la_vector_t v1, v2, v3, v4; // вспомагательные вектора
  // примечание: v2 - вектор состояния, остальные временные переменные
} la_cine_t;

// класс двойного кинематического фильтра
// Идея фильтра:
//   Каскадное включение двух кинематических фильтров
//   с целью фильтрации как координаты так и скорости
typedef struct {
  la_cine_t fx; // фильтр координаты
  la_cine_t fv; // фильтр скорости
} la_cine2_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// *************************************
// методы класса кинематического фильтра
// *************************************

// инициализация кинематического фильтра
void la_cine_init(
  la_cine_t *cine,      // структура фильтра
  int vector_size,      // размер фильтруемого вектора
  int filt_size,        // размер фильтра
  const la_float_t *k); // импульсная характеристика FIR фильтра [filt_size]

// деинициализация кинематического фильтра
void la_cine_free(la_cine_t *cine);

// произвести установку кинематического фильтра в начальное состояние
// ("форсированный разгон тяжелого фильтра")
void la_cine_start(
  la_cine_t *cine,      // структура фильтра
  const la_float_t *x,  // выборка вектора (X)
  const la_float_t *v); // выборка производной вектора (X с точкой)

// выполнить шаг кинематического фильтра
void la_cine_step(
  la_cine_t *cine,       // структура фильтра
  la_float_t dt,         // шаг разбиения (обычно приращение времени)
  const la_float_t *x,   // входная выборка вектора (X)
  const la_float_t *v,   // входная выборка производной вектора (X с точкой)
  la_float_t *X);        // выходная выборка вектора

// **********************************************
// методы класса двойного кинематического фильтра
// **********************************************

// инициализация двойного кинематического фильтра
void la_cine2_init(
  la_cine2_t *cine2,      // структура фильтра
  int vector_size,        // размер фильтруемого вектора
  int filt_size_x,        // размер фильтра для координаты (X)
  int filt_size_v,        // размер фильтра для скорости (V)
  const la_float_t *k_x,  // импульсная характеристика фильтра (по X)
  const la_float_t *k_v); // импульсная характеристика фильтра (по V)

// деинициализация двойного кинематического фильтра
void la_cine2_free(la_cine2_t *cine2);

// произвести установку двойного кинематического фильтра в начальное состояние
// ("форсированный разгон тяжелого фильтра")
void la_cine2_start(
  la_cine2_t *cine2,    // структура фильтра
  const la_float_t *x,  // выборка вектора (X)
  const la_float_t *v,  // выборка производной вектора (X с точкой)
  const la_float_t *a); // выборка второй производной вектора

// выполнить шаг двойного кинематического фильтра
void la_cine2_step(
  la_cine2_t *cine2,   // структура фильтра
  la_float_t dt,       // шаг разбиения (обычно приращение времени)
  const la_float_t *x, // входная выборка вектора
  const la_float_t *v, // входная выборка производной вектора
  const la_float_t *a, // входная выборка второй производной вектора
  la_float_t *X,       // выходная выборка вектора
  la_float_t *V);      // выходная выборка производной вектора

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // LA_CINE_H

/*** end of "la_cine.h" file ***/

