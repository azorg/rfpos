/*
 * Вычисление координат передатчика по задержкам сигнала до приёмников
 * Version: 0.1a
 * File: "rfpos.c"
 * Coding: UTF8
 * (C) 2018 Alex Zorg <azorg@mail.ru>
 * Licensed by GNU General Public License version 2
 */
//----------------------------------------------------------------------------
#include <math.h> // sqrt()
#include <stdio.h> // printf()
#include "rfpos.h"
//----------------------------------------------------------------------------
// инициализация основного компонента, выделение памяти
// (в случае ошибки возращается отрицательный код ошибки)
void rfpos_init(
  rfpos_t *self, // структура данных компонента
  int d,         // максимальная размерность координат (2 или 3)
  int n)         // максимальное число приёмников
{
  if (d < 2) d = 2;
  if (n <= d) n = d + 1;

  self->n = n;
  self->d = d;

  la_matrix_init(&self->y, n, d + 1); // матрица входных данных
  la_vector_init(&self->x, d + 1);    // искомый вектор
  la_vector_init(&self->f, n);        // вектор "невязки"
  la_matrix_init(&self->w, n, d + 1); // матрица Якоби
}
//----------------------------------------------------------------------------
// деинициализация компонента, освобождение памяти
void rfpos_free(rfpos_t *self)
{
  la_matrix_free(&self->w);
  la_vector_free(&self->f);
  la_vector_free(&self->x);
  la_matrix_free(&self->y);
}
//----------------------------------------------------------------------------
// функция вычисления вектора невязки F(X,Y)
static void rfpos_f(
    int n, int d,         // число приёмников, размерность задачи
    const la_vector_t *x, // выбранная точка в простанстве и времени
    const la_matrix_t *y, // входные данные
    la_vector_t *f)       // значение невязки
{
  int i, j;

  for (i = 0; i < n; i++)
  {
    double s = 0., q;
    for (j = 0; j < d; j++)
    {
      q = x->d[j] - y->d[i][j];
      s += q * q;
    }
    q = x->d[d] - y->d[i][d];
    f->d[i] = s - q * q;
  }
}
//----------------------------------------------------------------------------
// функция вычисления значения матрицы Якоби W(X,Y)
static void rfpos_w(
    int n, int d,         // число приёмников, размерность задачи
    const la_vector_t *x, // выбранная точка в простанстве и времени
    const la_matrix_t *y, // входные данные
    la_matrix_t *w)       // матрица Якоби
{
  int i, j;
  
  for (i = 0; i < n; i++)
  {
    for (j = 0; j < d; j++)
      w->d[i][j] = 2. * (x->d[j] - y->d[i][j]);
    w->d[i][d] =  -2. * (x->d[d] - y->d[i][d]); 
  }
}
//----------------------------------------------------------------------------
// основная функция для численного решения системы квадратных уравнений
// (в случае ошибки возращается отрицательный код ошибки,
// в случае успеха - число выполненных итераций)
// координаты передаются и возвращаются в метрах, время в секундах
int rfpos_calc(
  rfpos_t *self, // структура данных компонента
  // на входе:
  int it,          // максимальное число итераций
  double e,        // желаемая численная точность оценки координат [м]
  int d,           // размерность координат или число неизвестных (2 или 3)
  int n,           // число приёмников, принявших задерженный сигнал (n > d)
  const double *m, // матрица координат приёмников [n][d]
  const double *t, // вектор временных меток приёма сигнала приёмниками [n]
  const double *p, // радиус вектор предпологаемого нахождения приёмника [d]
  // на выходе:
  double *t0, // оценка времени излучения сигнала передатчиком
  double *r)  // радиус вектор приёмника, если решение найдено [d]
{
  int i, j;
  double tmin, d0;
  const double *ptr;
  
  if (n > self->n) return -1; // ошибка
  if (d > self->d) return -2; // ошибка
  
  e *= e;

  // найти минимальнье значение t[i]
  tmin = t[0];
  for (i = 1; i < n; i++)
    if (tmin > t[i]) tmin = t[i];

  // FIXME
  printf(">>> tmin = %.8g\n", tmin);

  // заполнить матрицу исходных данных
  ptr = m;
  for (i = 0; i < n; i++)
  {
    for (j = 0; j < d; j++)
      self->y.d[i][j] = *ptr++;

    self->y.d[i][d] = (t[i] - tmin) * RFPOS_C; // секунды -> метры
  }
  
  // FIXME
  printf(">>> d:");
  for (i = 0; i < n; i++)
    printf(" %g", self->y.d[i][d]);
  printf("\n");

  // вычислить оценку d0 искомой точки
  d0 = 0.;
  for (i = 0; i < n; i++)
  {
    double dd = 0.;
    for (j = 0; j < d; j++)
    {
      double q = p[j] - self->y.d[i][j];
      dd += q * q;
    }
    d0 += self->y.d[i][d] - sqrt(dd);
  }
  d0 /= (double) n;

  // FIXME
  printf(">>> t0 ~ %.8g\n", d0 / RFPOS_C + tmin);

  // заполнить исходную точку поиска решения
  for (j = 0; j < d; j++)
    self->x.d[j] = p[j];
  self->x.d[d] = d0;
  
  // цикл итераций Ньютона
  for (i = 0;; i++)
  {
    int err;
    double s, q;

    // вычислить "невязку"
    rfpos_f(n, d, &self->x, &self->y, &self->f);

    // FIXME
    printf(">>> f:");
    for (j = 0; j < n; j++)
      printf(" %g", self->f.d[j]);
    printf("\n");

    // оценить невязку по модулю
    s = 0.;  
    for (j = 0; j <= d; j++)
    {
      q = self->f.d[j];
      s += q * q;
    }
    printf(">>> mod(f) = %g [m]\n", sqrt(s)); // FIXME
    if (s <= e)
      break; // успех: достигнута требуемая точность

    // проверить лимит итераций
    if (i >= it)
      break; // превышен лимит итераций
  
    // вычислить матрицу Якоби
    rfpos_w(n, d, &self->x, &self->y, &self->w);
      
    // решить систему линейных уравнений
    self->dx = la_svd_simple(&self->w, &self->f, &err);
    if (err < 0)
      break; // ошибка решения ?! Почему? FIXME

    // FIXME
    printf(">>> dx:");
    for (j = 0; j <= d; j++)
      printf(" %g", self->dx.d[j]);
    printf("\n");

    // выполнить коррекцию: x += dx
    for (j = 0; j <= d; j++)
      self->x.d[j] -= self->dx.d[j];

    // FIXME
    printf(">>>");
    for (j = 0; j < d; j++)
      printf(" %f", self->x.d[j]);
    printf("\n");

    la_vector_free(&self->dx);
  }

  // заполнить выходные данные
  *t0 = self->x.d[d] / RFPOS_C + tmin;

  for (j = 0; j < d; j++)
    r[j] = self->x.d[j];

  return i; // вернуть число выполненных итераций
}
//----------------------------------------------------------------------------
// функция тестирования
void rfpos_test(
  // на входе:
  int d,           // размерность координат или число неизвестных (2 или 3)
  int n,           // число приёмников, принявших задерженный сигнал (n > d)
  const double *m, // матрица координат приёмников [n][d]
  const double *p, // радиус нахождения приёмника [d]
  double t0,       // время излучения сигнала передатчиком
  // на выходе:
  double *t) // вектор временных меток приёма сигнала приёмниками [n]
{
  int i, j;
  const double *ptr = m;

  for (i = 0; i < n; i++)
  {
    double q, s = 0.;
    for (j = 0; j < d; j++)
    {
      q = p[j] - *ptr++;
      s += q * q;
    }
    t[i] = sqrt(s) / RFPOS_C + t0;
  }
}
//----------------------------------------------------------------------------


/*** end of "rfpos.c" ***/

